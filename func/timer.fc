;; Timer smart-contract for scheduling messages.
;;    v1 - [current]
;;    v2 - [planned] sharding support
;; (c) ProgramCrafter, 2022


#include "func/stdlib-ext.fc";


{-
slice owner_address() asm "b{100} x{00} |+ x{dab812df8ae259099c63455c8d1c3775eed2622425532e2dd8a8a33be132a3f5} |+ PUSHSLICE";
;;                           |      |        |
;;                           |      |        -- address in binary form
;;                           |      -- workchain tag
;;                           -- MsgAddressInt tag
-}

;; testnet version
slice owner_address() asm "b{100} x{00} |+ x{15be3c3171911009bbcc473d07d8fc2bcc0c7192fed2237719da256e07fa7948} |+ PUSHSLICE";


() send_schedule_loop_msg() impure {
  send_raw_message(
     begin_cell()
    .store_uint(0x18, 6)
    .store_slice(my_address())
    .store_coins(500000000)     {-  0.5 TON  -}
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)   {-  no message body here  -}
    .end_cell(), 0);
}


int continue_parsing(int success, int scheduled_at, int current_time) inline_ref {
  ;; lazy evaluation required, because `scheduled_at` is nullable
  if (~ success) {
    return 0;
  }
  return scheduled_at <= current_time;
}
() process_schedule() impure {
  (_, cell scheduled) = get_data().begin_parse().load_dict();
  
  int current_time = now();
  
  (int scheduled_at, slice schedules, int success) = udict_get_min?(scheduled, 32);
  while (continue_parsing(success, scheduled_at, current_time)) {
    cell addr = schedules~load_ref();
    cell body = schedules~load_ref();
    
    send_raw_message(
       begin_cell()
      .store_uint(0x18, 6)
      .store_slice(addr.begin_parse())
      .store_coins(200000000)                       {-  returning 0.2 TON out of 1.0      -}
      .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)   {-  message body stored in reference  -}
      .store_ref(body)
      .end_cell(), 0);
    
    int t = scheduled~udict_delete?(32, scheduled_at);
    (int scheduled_at, slice schedules, int success) = udict_get_min?(scheduled, 32);
  }
  
  set_data(begin_cell().store_dict(scheduled).end_cell());
  
  send_schedule_loop_msg();
}


() put_scheduled(slice in_msg) impure {
  int schedule_at = in_msg~load_uint(32);
  schedule_at += rand(4096);    {-  The Open Network doesn't support precision higher than 5s  -}
                                {-  avoiding collisions near beautiful numbers  -}
  
  (_, cell scheduled) = get_data().begin_parse().load_dict();
  (slice old_schedule_here, int old_schedule_exist) = udict_get?(scheduled, 32, schedule_at);
  throw_if(101, old_schedule_exist);
  
  cell schedule_to = in_msg~load_ref();
  cell body = in_msg~load_ref();
  
  scheduled~udict_set_builder(32, schedule_at, begin_cell().store_ref(schedule_to).store_ref(body));
  
  set_data(begin_cell().store_dict(scheduled).end_cell());
}


;;    ========================================================    ;;
;;    \\      ||                                    ||      //    ;;
;;     XX     ||    Processing incoming messages    ||     XX     ;;
;;    //      ||                                    ||      \\    ;;
;;    ========================================================    ;;


() recv_internal(int coins, cell in_msg_full, slice in_msg) impure {
  {------------------------------------------------------}
  {-    Extracting source address from CommonMsgInfo    -}
  {------------------------------------------------------}
  
  slice in_msg_full = in_msg_full.begin_parse();
  if (in_msg_full~load_uint(4) & 1) {  ;; int_msg_info$0, ihr_disabled, bounce, bounced
    return ();
  }
  slice src = in_msg_full~load_msg_addr();
  int src_hash = slice_hash(src);
  
  {----------------------------------------------------}
  {-    Messages from self for processing schedule    -}
  {-    [FASTPATH]                                    -}
  {----------------------------------------------------}
  if (src_hash == slice_hash(my_address())) {
    process_schedule();
    
    return ();
  }
  
  
  {----------------------------------------------------------}
  {-    No message present - considering this a donation    -}
  {----------------------------------------------------------}
  if (in_msg.slice_bits() < 32) {
    return ();
  }
  
  {------------------------------------------------------}
  {-    Owner can take TON obtained by this contract    -}
  {------------------------------------------------------}
  if (src_hash == slice_hash(owner_address())) {
    var request_nton = in_msg~load_uint(64);
    
    if (request_nton == 1) {
      {--------------------------------------------------------------------}
      {-    Too small values are not sensical so using them as opcodes    -}
      {--------------------------------------------------------------------}
      send_schedule_loop_msg();
      return ();
    }
    
    send_raw_message(
       begin_cell()
      .store_uint(0x18, 6)
      .store_slice(owner_address())
      .store_coins(request_nton)
      .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)   {-  no message body here  -}
      .end_cell(),
      
      1   {-  paying transfer fees separately so exactly `request_nton` is delivered  -}
    );
    
    return ();
  }
  
  {-------------------------------------------}
  {-    Incoming message - maybe schedule    -}
  {-------------------------------------------}
  
  throw_if(100, coins < 1000000000);    ;; at least 1 TON is required for message scheduling
                                        ;; 0.2 TON will be returned later
  
  put_scheduled(in_msg);
}

() recv_external() impure {
  [int balance, _] = get_balance();
  
  if (balance < 100000000) {  ;; 0.1 TON
    accept_message();
  }
}
