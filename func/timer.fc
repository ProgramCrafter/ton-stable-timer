;; Timer smart-contract for scheduling messages.
;; (c) ProgramCrafter, 2022

#include "func/utils-timer.fc";

;; TIM::TIM::main
() recv_internal(int coins, cell in_msg_full, slice in_msg) impure {
  {------------------------------------------------------}
  {-    Extracting source address from CommonMsgInfo    -}
  {------------------------------------------------------}
  
  slice in_msg_full = in_msg_full.begin_parse();
  int bounced = in_msg_full~load_uint(4);  ;; int_msg_info$0, ihr_disabled, bounce, bounced
  
  slice src = in_msg_full~load_msg_addr();
  
  {----------------------------------------------------}
  {-    Messages from self for processing schedule    -}
  {-    bounced from masterchain to slow down timer   -}
  {-    [FASTPATH]                                    -}
  {----------------------------------------------------}
  if (equal_slices(src, unused_masterchain_address())) {
    TIM::process_schedule();
    
    return ();
  }
  
  
  if (bounced & 1) {
    return ();
  }
  
  {----------------------------------------------------------}
  {-    No message present - considering this a donation    -}
  {----------------------------------------------------------}
  if (in_msg.slice_bits() < 32) {
    return ();
  }
  
  int opcode = in_msg~load_uint(32);
  
  {-------------------------------}
  {-    Next bell time update    -}
  {-------------------------------}
  if (opcode == op::update_next_wakeup) {
    in_msg = TIM::check_ident_proof(src, in_msg);
    
    slice old_timer_data = get_data().begin_parse();
    
    throw_if(120, old_timer_data~load_uint(32) != in_msg.preload_uint(32));
    throw_if(121, old_timer_data~load_uint(1) == 0);
    
    int next_time = in_msg~load_uint(32);
    
    builder new_timer_data = begin_cell().store_uint(next_time, 32);
    
    slice root_addr = old_timer_data~load_msg_addr();
    throw_if(122, equal_slices(root_addr, src));
    new_timer_data~store_slice(root_addr);
    new_timer_data~store_ref(old_timer_data~load_ref());
    new_timer_data~store_slice(old_timer_data);
    set_data(new_timer_data.end_cell());
    
    TIM::send_schedule_loop_msg();
    
    return ();
  }
  if (opcode == op::root_update_next_wakeup) {
    in_msg = TIM::check_ident_proof(src, in_msg);
    
    slice old_timer_data = get_data().begin_parse();
    old_timer_data~skip_bits(32);
    throw_unless(126, old_timer_data~load_uint(1));
    
    slice root_addr = old_timer_data~load_msg_addr();
    throw_unless(127, equal_slices(root_addr, src));
    
    slice in_msg_copy = in_msg;
    int next_time = 0xFFFFFFFF;
    if (in_msg_copy~load_uint(1)) {
      in_msg_copy~load_msg_addr();
      in_msg_copy~skip_bits(64);
      next_time = in_msg_copy~load_uint(32);
      
      TIM::send_schedule_loop_msg();
    }
    
    builder new_timer_data = begin_cell()
      .store_uint(next_time, 32)
      .store_slice(in_msg)
      .store_ref(old_timer_data~load_ref());
    
    set_data(new_timer_data.end_cell());
    
    return ();
  }
  
  {------------------------------------------------------}
  {-    Owner can take TON obtained by this contract    -}
  {------------------------------------------------------}
  if (equal_slices(src, owner_address())) {
    int request_nton = (opcode << 32) + in_msg~load_uint(32);
    
    if (request_nton == 1) {
      {--------------------------------------------------------------------}
      {-    Too small values are not sensical so using them as opcodes    -}
      {--------------------------------------------------------------------}
      TIM::send_schedule_loop_msg();
      return ();
    }
    
    [int balance, _] = get_balance();
    int time_to_unix_epoch_end = 4294967295 - now();
    
    ;; Cost of maintaining contract is equal to 13 TON/h = 3'611'111 nTON/s.
    ;; This timer is able to work up to end of the Unix epoch (2**32 seconds - year 2106).
    ;; Assuring that there will be always enough money to work.
    
    ;; 10M TON will be sufficient to provide service from 2022 to 2106 years.
    ;; All excess money can be taken by me, author of the timer, for other purposes.
    
    throw_if(105, balance - request_nton < 3611111 * time_to_unix_epoch_end);
    
    send_raw_message(
       begin_cell()
      .store_uint(0x18, 6)
      .store_slice(owner_address())
      .store_coins(request_nton)
      .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)   {-  no message body here  -}
      .end_cell(), 0
    );
    
    return ();
  }
  
  {-------------------------------------------}
  {-    Incoming message - maybe schedule    -}
  {-------------------------------------------}
  
  throw_if(140, opcode != op::schedule_msg);
  
  ;; Components of message scheduling cost
  ;; 1. Forwarding TON amount           specified by user; not less than 0.01 TON
  ;; 2. Price for keeping timer awake.  6.5 TON/h = 6'500'000'000 nTON/h = 1'805'556 nTON/s
  ;; 3. Timer's profit.                 0.4 TON
  
  int schedule_at = in_msg~load_uint(32);
  int forward_nton = in_msg~load_uint(64);
  throw_if(100, forward_nton < 10000000);
  
  int timer_work_cost = 1805556 * max(0, schedule_at - now());
  
  throw_if(101, coins < timer_work_cost + forward_nton + 400000000);
  
  TIM::create_bell(rand(18446744073709551616), schedule_at, forward_nton,
    in_msg~load_msg_addr(), in_msg~load_ref());
  
  send_raw_message(
     begin_cell()
    .store_uint(0x18, 6)
    .store_slice(owner_address())
    .store_coins(200000000)
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)   {-  no message body here  -}
    .end_cell(),
    
    1   {-  paying transfer fees separately so exactly 0.2 TON is delivered  -}
  );
}

() recv_external() {
  
}
